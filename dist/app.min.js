"use strict";

var logGrid = function() {
  var rows = [];
  for(var x = 0; x < _grid.length; x++) {
    var row = [];
    for(var y = 0; y < _grid[x].length; y++) {
      var cell = _grid[x][y];
      row[y] = "" + (cell < 10 ? " "+cell : cell);
    }
    rows[x] = row.join(" ");
  }
  console.info(rows.join("\n"));
};

// F  H  N E S W
// 32 16 8 4 2 1
var lvl1 = [
   5, 5,
  20, 12, 10, 20, 20,
  10,  5, 12, 18, 10,
  11,  6,  5,  9,  7,
  13, 18, 10,  5, 10,
   9, 42, 11,  6, 18
];

var _grid = [],
    _factory,
    gameboard = document.getElementById("gameboard");

var FACTORY = 32;
var HOUSE = 16;
var N = 8;
var E = 4;
var S = 2;
var W = 1;

var noContextMenu = function(e) {
  e.stopPropagation();
  e.preventDefault();
};

var getTileLayout = function (links) {
  switch(links) {
    case N: case E: case S: case W:
      return 'O'; break;
    case N|E: case S|E: case S|W: case N|W:
      return 'L'; break;
    case N|S: case W|E:
      return 'I'; break;
    case N|S|W: case N|S|E: case N|W|E: case S|W|E:
      return 'T'; break;
  }
}

var getTileRotation = function (links) {
  switch(links) {
    case N: case N|S: case N|E: case N|S|E:
      return 0; break;
    case E: case W|E: case S|E: case S|W|E:
      return 90; break;
    case S: case S|W: case N|S|W:
      return 180; break;
    case W: case N|W: case N|W|E:
      return 270; break;
  }
}

var incrementMoveCount = (function() {
  var moveCount = 0,
      moveCountEl = document.getElementById("move-count");

  moveCountEl.textContent = moveCount + " moves";

  return function _incrementMoveCount() {
    moveCount++;
    moveCountEl.textContent = moveCount + " moves";
  }
})();

var checkFinished = function() {
  if(document.querySelector(".tile[data-power=\"0\"]") == null) {
    alert("Solved!");
  }
}

var Tile = function(x, y, data){
  var self = this,
      data = data,
      type,
      x = x,
      y = y,
      links = data & 15, // last 4 bits
      domEl;

  var getNeighbor = function Tile_getNeighbor(direction) {

    if(!self.isConnected(direction)) {
      return false;
    }

    switch(direction) {
      case N:
        return y > 0                 && _grid[y-1][x  ]; break;
      case S:
        return y < _grid.length-1    && _grid[y+1][x  ]; break;
      case W:
        return x > 0                 && _grid[y  ][x-1]; break;
      case E:
        return x < _grid[y].length-1 && _grid[y  ][x+1]; break;
      default:
        return false; break;
    }
  }

  var rotateRight = function Tile__rotateLeft() {
    incrementMoveCount();
    var turnover = (links & 1) == 1;
    links >>= 1;
    if(turnover) {
      links |= 8;
    }
    self.checkLights();
    self.render();
    checkFinished();
  };
  var rotateLeft = function Tile__rotateRight() {
    incrementMoveCount();
    var turnover = (links & 8) == 8;
    links <<= 1;
    links &= 15;
    if(turnover) {
      links |= 1;
    }
    self.checkLights();
    self.render();
    checkFinished();
  };

  this.isFactory = function Tile__isFactory() {
    return type == FACTORY;
  }
  this.isConnected = function Tile__isConnected(direction) {
    return (links & direction) == direction;
  }

  this.hasPower = function Tile__hasPower() {
    return domEl.getAttribute("data-power") === "1";
  }

  this.checkLights = function Tile__checkLights(calledFrom) {

    var wasPoweredBefore = self.hasPower(),
        directions = [N,S,W,E],
        sources ;

    // if this is the factory, it has no sources (and does not need one)
    if(self.isFactory()) {
      sources = [];

    // if not, the look if some neighbor cell has power
    } else {
      sources = directions.reduce(function(acc, val) {
        var n = getNeighbor(val),
            directionReversed = ((val | val << 4) >> 2) & 15;
        if(!!n && n.isConnected(directionReversed) && n.hasPower()) {
          return acc.concat(val);
        } else {
          return acc;
        }
      }, []);
    }

    // if at least one neighbor cell has power or this is the factory
    if(sources.length > 0 || self.isFactory()) {

      // power it on
      domEl.setAttribute("data-power", "1");

      // and if this changed something...
      if(calledFrom === undefined || !wasPoweredBefore) {
        // ...tell all not-source-neighbor cells to check their lights
        directions.forEach(function(val) {
          if(sources.indexOf(val) > -1 || val == calledFrom) {
            return;
          }
          var n = getNeighbor(val);
          if(n !== false) {
            var directionReversed = ((val | val << 4) >> 2) & 15;
            n.checkLights(directionReversed);
          }
        });
      }

    // power off :(
    } else {

      domEl.setAttribute("data-power", "0");

      // and if this changed something...
      if(calledFrom === undefined || wasPoweredBefore) {
        // ...tell all neighbor cells to check their lights
        directions.forEach(function(val) {
          if(val !== calledFrom) {
            var n = getNeighbor(val);
            if(n !== false) {
              var directionReversed = ((val | val << 4) >> 2) & 15;
              n.checkLights(directionReversed);
            }
          }
        });
      }
    }

  }

  this.render = function Tile__render() {
    domEl.setAttribute("data-rotation", getTileRotation(links));
  };

  this._x = x;
  this._y = y;

  if((data & 16) == 16) {
    if((data & 32) == 32) { 
      throw new TypeError("Corrupt data. Cell " + x + "|" + y + " has set both house and factory");
    } else {
      type = HOUSE;
    }
  } else if((data & 32) == 32) {
    type = FACTORY;
  }

  if(links == 0) {
    throw new TypeError("Corrupt data. Cell " + x + "|" + y + " has no lines");
  } else if(links == 15) {
    throw new TypeError("Corrupt data. Cell " + x + "|" + y + " is a cross");
  }

  domEl = document.createElement("div");
  domEl.appendChild(document.createElement("div"));
  domEl.appendChild(document.createElement("div"));
  domEl.classList.add("tile");
  if(type == HOUSE) {
    domEl.classList.add("house");
  } else if(type == FACTORY) {
    domEl.classList.add("factory");
  }
  domEl.setAttribute("data-layout", getTileLayout(links));
  domEl.setAttribute("data-power", "0");
  domEl.oncontextmenu = noContextMenu;
  domEl.onmouseup = function(e) {
    if(e.which == 3) {
      rotateLeft();
    } else if(e.which == 1) {
      rotateRight();
    }
  }
  domEl.ontouchend = function(e) {
    e.preventDefault();
    rotateRight();
  }
  domEl.ontouchmove = function(e) {
    e.preventDefault();
    return false;
  }
  gameboard.appendChild(domEl);

  this.toString = function Tile__toString() {

    switch(links) {
      case 1:  return "`"; break;
      case 2:  return ","; break;
      case 3:  return "┐"; break;
      case 4:  return "´"; break;
      case 5:  return "─"; break;
      case 6:  return "┌"; break;
      case 7:  return "┬"; break;
      case 8:  return "^"; break;
      case 9:  return "┘"; break;
      case 10: return "|"; break;
      case 11: return "┤"; break;
      case 12: return "└"; break;
      case 13: return "┴"; break;
      case 14: return "├"; break;
      
    }
  }
};


var loadGame = function __loadGame(data) {
  var sizeX = data[0],
      sizeY = data[1];

  if(data.length - 2 != sizeX * sizeY) {
    throw new TypeError("Corrupt data. Grid size specification does not match data size");
  }

  for(var y = 0, i = 2; y < sizeY; y++) { // rows
    var row = [];
    for(var x = 0; x < sizeX; x++, i++) { // cells
      row[x] = new Tile(x, y, data[i]);
    }
    _grid[y] = row;
  }

  for(var x = 0; x < sizeX; x++) {
    for(var y = 0; y < sizeY; y++) {
      _grid[x][y].render();
      if(_grid[x][y].isFactory()) {
        _grid[x][y].checkLights();
      }
    }
  }
};

var clearGame = function __clearGame() {
  _grid = [];
  gameboard.innerHTML = "";
}

loadGame(lvl1);
